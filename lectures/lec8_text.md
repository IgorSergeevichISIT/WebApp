# Введение в React

Добрый день, коллеги! Сегодня мы начинаем изучение одной из самых востребованных библиотек для разработки пользовательских интерфейсов - React. В рамках нашего курса "Разработка интернет приложений" это ключевая технология, поскольку React является стандартом де-факто в большинстве компаний, занимающихся веб-разработкой. Сегодня мы рассмотрим основные концепции React и научимся создавать простые приложения.

## Трехзвенная архитектура. AJAX

На предыдущих занятиях мы уже рассмотрели трехзвенную архитектуру веб-приложений, которая включает в себя клиентскую часть (фронтенд), серверную часть (бэкенд) и базу данных[1]. На диаграмме развертывания мы четко обозначили наши бэкенд и фронтенд компоненты, включая IP-адреса и порты, используемые этими приложениями[1].

Трехзвенная архитектура позволяет нам разделить ответственность между компонентами: фронтенд отвечает за пользовательский интерфейс, бэкенд реализует бизнес-логику, а база данных хранит информацию. При этом для коммуникации между фронтендом и бэкендом часто используется технология AJAX, позволяющая асинхронно обмениваться данными без перезагрузки страницы.

## Web-фреймворки. Фронтенд

На сегодняшний день существует множество фреймворков для разработки фронтенд-приложений на JavaScript и TypeScript[1]. Самым распространенным как в России, так и во всем мире является React[1]. Он разрабатывается и поддерживается компанией Meta (ранее Facebook)[1].

Важно отметить, что React технически не является полноценным фреймворком - это библиотека для создания пользовательских интерфейсов. Однако в сочетании с другими инструментами (роутерами, менеджерами состояний и т.д.) образует мощную экосистему для разработки современных веб-приложений.

## Сравнение популярности фреймворков

Если мы посмотрим на диаграмму, которая разделяет положительный ("хочу изучить", "буду использовать снова") и отрицательный ("не интересно", "не буду использовать снова") опыт разработчиков, то увидим, что React находится на самом верху позитивной половины[1]. За ним следуют Svelte и Vue.js, также с высоким уровнем положительных отзывов[1].

Толщина полос на диаграмме отражает количество разработчиков, знакомых с технологией, и для React эта полоса самая широкая, что свидетельствует о его широком распространении[1].

В нижней части, на негативной половине диаграммы, расположились Angular, Ember и Stencil, что может говорить о их меньшей популярности или более сложной кривой обучения[1].

## DOM

DOM (Document Object Model) - это объектная модель документа, представляющая HTML-страницу в виде дерева объектов[1]. В соответствии с этой моделью, каждый HTML-тег является объектом[1]. Вложенные теги становятся "детьми" родительского элемента, а текст внутри тегов также является объектом[1].

Все эти объекты доступны из JavaScript, и мы можем манипулировать ими для динамического изменения содержимого страницы[1]. Вот пример простого HTML-документа:

```html



    О лосях


    Правда о лосях.


```

React работает с DOM особым образом - он использует концепцию виртуального DOM, что позволяет оптимизировать обновления интерфейса и повысить производительность приложений.

## Компоненты

Основой React являются компоненты - повторно используемые части кода, которые возвращают React-элементы для отображения на странице[1]. Существует два типа компонентов: функциональные и классовые[1].

Функциональный компонент - это JavaScript-функция, принимающая props и возвращающая React-элемент:

```jsx
function Welcome(props) {
    return Привет, {props.name};
}
```

Классовый компонент - это класс JavaScript, который наследуется от React.Component и содержит метод render():

```jsx
class Welcome extends React.Component {
    render() {
        return Привет, {this.props.name};
    }
}
```

Компонентный подход позволяет разделить приложение на независимые, переиспользуемые блоки, что значительно упрощает разработку и поддержку сложных интерфейсов.

## Props

Props (пропсы) - это входные данные React-компонентов, передаваемые от родительского компонента дочернему[1]. Они аналогичны аргументам функций в JavaScript или атрибутам в HTML.

В любом компоненте доступны props.children - это контент между открывающим и закрывающим тегом компонента[1]. Для классовых компонентов используется this.props.children[1].

Вот пример интерфейса для props компонента BrowserRouter из библиотеки react-router:

```tsx
export interface BrowserRouterProps {
    basename?: string | undefined; 
    children?: React.ReactNode;
    getUserConfirmation?: ((message: string, callback: (ok:
    forceRefresh?: boolean | undefined;
    keyLength?: number | undefined;
}
```

В классовом компоненте доступ к props осуществляется через this.props:

```jsx
class Welcome extends React.Component {
    render() {
        return Привет, {this.props.name};
    }
}
```

Props являются иммутабельными (неизменяемыми) - компонент, получающий props, не должен их модифицировать.

## Состояние

Компонент нуждается в состоянии (state), когда данные в нём со временем изменяются[1]. Например, компоненту Checkbox может понадобиться состояние isChecked для отслеживания, выбран ли чекбокс[1].

Основное различие между props и state заключается в том, что состояние используется для управления компонентом изнутри, а props - для получения информации извне[1].

В классовых компонентах состояние инициализируется в конструкторе и обновляется через метод setState(), а в функциональных компонентах для управления состоянием используется хук useState().

## Жизненный цикл приложения

Жизненный цикл компонента в React можно разделить на три основные фазы[1]:

1. Монтирование: компонент запускает getDerivedStateFromProps(), затем render(), возвращающий JSX, и React "монтирует" результат в DOM[1].

2. Обновление: этот этап запускается при каждом изменении состояния либо свойств компонента[1].

3. Размонтирование: перед удалением компонента из DOM, React выполняет метод componentWillUnmount()[1].

Понимание жизненного цикла компонентов критически важно для правильного управления ресурсами и оптимизации производительности React-приложений.

## Методы жизненного цикла

Классовые компоненты React имеют набор методов жизненного цикла, которые вызываются на разных этапах существования компонента[1]. К ним относятся:

- Методы монтирования (constructor, getDerivedStateFromProps, render, componentDidMount)
- Методы обновления (getDerivedStateFromProps, shouldComponentUpdate, render, getSnapshotBeforeUpdate, componentDidUpdate)
- Методы размонтирования (componentWillUnmount)
- Методы обработки ошибок (getDerivedStateFromError, componentDidCatch)

Эти методы позволяют контролировать поведение компонента на каждом этапе его существования.

## Функциональные компоненты

Функциональные компоненты представляют собой более современный и предпочтительный способ создания компонентов в React[1]. Они имеют ряд преимуществ:

1. Создание компонентов с помощью чистых функций приводит к меньшему объему кода, что упрощает его поддержку[1].

2. Чистые функции проще тестировать - достаточно передать props на вход и проверить полученную разметку[1].

3. В перспективе функциональные компоненты будут выигрывать по производительности в сравнении с классовыми из-за отсутствия методов жизненного цикла[1].

С появлением хуков в React 16.8 функциональные компоненты получили все возможности классовых компонентов, сохранив при этом лаконичность и удобство использования.

## Хуки

Хуки - это функции, которые позволяют использовать состояние и другие возможности React в функциональных компонентах[1]. Рассмотрим пример использования хуков useState и useEffect:

```jsx
import React, { useEffect, useState } from 'react'
import Axios from 'axios'
export default function Hello() {
    const [Name, setName] = useState("")
    useEffect(() => {
        Axios.get('/api/user/name')
        .then(response => {
            setName(response.data.name)
        })
    }, [])
    return (
        
            My name is {Name}
        
    )
}
```

Для сравнения, вот эквивалентный классовый компонент:

```jsx
import React, { Component } from 'react'
import Axios from 'axios'
export default class Hello extends Component {
    constructor(props) {
        super(props);
        this.state = { name: ""};
    }
    componentDidMount() {
        Axios.get('/api/user/name')
        .then(response => {
            this.setState({ name: response.data.name })
        })
    }
    render() {
        return (
            
                My name is {this.state.name}
            
        )
    }
}
```

Как видим, функциональный компонент с хуками значительно компактнее и читабельнее.

## Vite

Vite - это современное окружение для разработки и сборщик для JavaScript-приложений[1]. В нашем курсе мы будем использовать Vite вместо Create React App (CRA) для создания React-приложений[1].

Vite поддерживает как React, так и Vue.js[1], а также предлагает ряд преимуществ:
- Мгновенный запуск сервера разработки
- Hot Module Replacement, который остается быстрым независимо от размера приложения
- Обслуживание файлов по требованию через нативный ESM, без необходимости сборки
- Предварительно настроенная сборка с Rollup

Для создания нового проекта с Vite используются следующие команды:

```bash
npm create vite@latest my-app -- --template react-ts
cd my-app
npm install
```

## Структура проекта Vite

После создания проекта с помощью Vite, в папке проекта будут следующие файлы[1]:

- package.json - основной файл с информацией о проекте, включая зависимости и скрипты[1]
- package-lock.json - файл с точными версиями зависимостей[1]
- vite.config.ts - конфигурационный файл сборщика Vite[1]
- tsconfig.json - конфигурация TypeScript[1]
- tsconfig.node.json - конфигурация TypeScript для Node.js[1]
- .eslintrc.cjs - конфигурация ESLint[1]
- index.html - основной файл приложения, который загружается первым[1]
- src/main.tsx - основной TypeScript файл, инициализирующий приложение[1]
- src/App.tsx - главный компонент приложения с логотипами Vite и React[1]

Эта структура обеспечивает организованный подход к разработке с использованием современных инструментов.

## ES6

ECMAScript 2015 (ES6) - это значительное обновление JavaScript, которое ввело множество новых возможностей[1]:

1. Оператор spread для разворачивания массивов:
```javascript
function foo(x, y, z) {
    console.log(x, y, z);
}
let arr = [1, 2, 3];
foo(...arr); // 1 2 3
```

2. Блочная область видимости с let и const:
```javascript
var a = 2;
{
    let a = 3;
    console.log(a); // 3
}
console.log(a); // 2
```

3. Классы для создания объектов:
```javascript
class Task {
    constructor() {
        console.log("Создан экземпляр task!");
    }
    showId() {
        console.log(23);
    }
    static loadAll() {
        console.log("Загружаем все tasks...");
    }
}
```

4. Rest-параметры для сбора аргументов:
```javascript
function foo(...args) {
    console.log(args);
}
foo(1, 2, 3, 4, 5); // [1, 2, 3, 4, 5]
```

5. Стрелочные функции:
```javascript
// Классическое функциональное выражение
let addition = function(a, b) {
    return a + b;
};
// Стрелочная функция
let addition = (a, b) => a + b;
```

## Babel - Компилятор JS

Babel - это инструмент, который преобразует современный JavaScript код в версию, совместимую со старыми браузерами[1]. Например, он трансформирует ES2015:

```javascript
const adding = (a, b) => a + b
```

В стандартный JavaScript:

```javascript
'use strict';
var adding = function adding(a, b) {
    return a + b;
};
```

Это позволяет разработчикам использовать новейшие возможности языка, не беспокоясь о совместимости с браузерами.

## WebPack в Create React App - альтернатива Vite

WebPack - это мощный сборщик модулей для JavaScript, который используется в Create React App[1]. Он принимает модули с зависимостями и генерирует статические ресурсы[1]. В отличие от Vite, WebPack выполняет полную сборку приложения даже в режиме разработки, что может замедлять процесс при работе с крупными проектами.

## JSX

JSX - это расширение синтаксиса JavaScript, используемое в React[1]. TSX - это то же самое, но для TypeScript[1]. Этот синтаксис внешне напоминает язык шаблонов, но обладает всеми возможностями JavaScript[1].

В результате компиляции JSX создаются простые объекты - "React-элементы"[1]. React DOM использует стиль именования camelCase для свойств вместо стандартных имён HTML-атрибутов[1]. Например, tabindex становится tabIndex, а class записывается как className, поскольку слово class зарезервировано в JavaScript[1].

JSX делает код React более наглядным и понятным, облегчая разработку пользовательских интерфейсов.

## Create React App vs Vite + React

Слайд демонстрирует визуальное сравнение приложений, созданных с помощью Create React App и Vite[1]. Хотя внешне они выглядят похоже, Vite обеспечивает значительно более быстрый процесс разработки благодаря использованию нативных ES-модулей браузера вместо полной сборки при каждом изменении.

## Основные файлы проекта

Рассмотрим ключевые файлы проекта React, созданного с Vite:

1. index.html - основной HTML-файл[1]:
```html


    
        
        
        
        Vite + React + TS
    
    
        
        
    

```

2. main.tsx - точка входа в приложение[1]:
```jsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import './index.css'
ReactDOM.createRoot(document.getElementById('root')!).render(
    
        
    ,
)
```

3. App.tsx - главный компонент[1]:
```jsx
import { useState } from 'react'
import reactLogo from './assets/react.svg'
import viteLogo from '/vite.svg'
import './App.css'
function App() {
    const [count, setCount] = useState(0)
    return (
        <>
            
                
                    
                
                
                    
                
            
            Vite + React
            
                 setCount((count) => count + 1)}>
                    count is {count}
                
                
                    Edit src/App.tsx and save to test HMR
                
            
            
                Click on the Vite and React logos to learn more
            
        
    )
}
```

## Роутинг

Для реализации маршрутизации в React-приложениях используется библиотека React Router[1]. Сначала необходимо установить пакеты:

```bash
npm i react-router-dom
npm i @types/react-router-dom -D
```

Затем настраиваем роутинг в основном файле приложения:

```jsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import { createBrowserRouter, RouterProvider } from 'react-router-dom'
import './index.css'
const router = createBrowserRouter([
{
path: '/',
element: Это наша стартовая страница
},
{
path: '/new',
element: Это наша страница с чем-то новеньким
}
])
ReactDOM.createRoot(document.getElementById('root')!).render(


,
)
```

Можно также добавить навигационное меню для перехода между страницами[1].

## CORS

CORS (Cross-Origin Resource Sharing) - это механизм, контролирующий доступ к ресурсам с другого домена[1]. Проблема возникает, когда фронтенд и бэкенд размещены на разных доменах или портах[1].

Существует два основных способа решения проблем с CORS:
1. Настройка соответствующих заголовков на бэкенде
2. Проксирование запросов через сервер фронтенда[1]

## Проксирование CORS

Один из способов обойти ограничения CORS - это проксирование запросов через сервер фронтенда[1]. Вместо прямых запросов к веб-сервису на другом домене, запросы отправляются на наш сервер фронтенда, который перенаправляет их дальше[1].

Это решение похоже на продакшн-конфигурацию с использованием Nginx[1] и может быть реализовано как в среде разработки Vite, так и в Create React App.

## React-Bootstrap vs MUI

React-Bootstrap и Material-UI (MUI) - это две популярные библиотеки компонентов для React[1]. Они предлагают готовые компоненты с различным дизайном: React-Bootstrap следует стилю Bootstrap, а MUI реализует Material Design от Google.

На слайде представлено сравнение различных компонентов обеих библиотек: таблицы, оповещения, кнопки, текстовые поля и другие элементы интерфейса[1].

## Figma MUI

Набор компонентов MUI доступен в Figma - популярном инструменте для дизайна интерфейсов[1]. Это позволяет дизайнерам создавать макеты, используя те же компоненты, которые будут применяться разработчиками[1].

В Figma можно использовать готовые компоненты MUI, иконки и другие элементы, что обеспечивает целостность дизайна и реализации[1].

## GitHub Pages

GitHub Pages - это бесплатный хостинг для статических файлов, позволяющий развернуть React-приложение без дополнительных затрат[1]. Мы можем опубликовать наше приложение непосредственно из репозитория GitHub[1].

GitHub Pages поддерживает настройку пользовательских доменов и обеспечивает шифрование HTTPS, что делает его удобным решением для демонстрации проектов или создания личных сайтов[1].

Это завершает наш обзор введения в React. В следующих лекциях мы углубимся в практическое использование этой библиотеки и разработку полноценных приложений.
